#'@title bocoo_associate
#'@description Creates a list including a data.frame of boiler-generator-cooling (bogencoo) associations
#'using the `inputData.list$bocoo`, `inputData.list$gen_fuel_data`, `inputData.list$boilerFuelData`,
#'`inputData.list$cooling`,`bogen.out.list$sheet3_key`,combogencoo_cool_type (either `data("combogencoo_cool_type2015")`
#'or from file), `data(bogencoo.key2015)` and the `associate()` function. Also in the list, is 
#'a data.frame named "manualBogencoo" which contains a list of all plants flagged for manual user
#'checks of the boiler-generator-cooling (bogencoo) associations and/or cooling type assignments. 
#'Use the `compilePlantInfo_excel()` function to generate a useful file to evaluate and manually edit
#'bogencoo associations and/or cooling type assignments. The output list will also include 
#'"combogencoo_cool_type" and "combogencoo_cool_type_nukes" which is simply the combogencoo_cool_type
#'file split into non-nuclear plants (in combogencoo_cool_type) and nuclear plants in 
#'(combogencoo_cool_type_nukes).  Note that some plants have both nuclear and non-nuclear units and 
#'will appear in both data.frames.
#'@param inputData.list list object generated by the importThermoEIA::import_EIAData() function 
#'This data is pulled from the EIA website (https://www.eia.gov/electricity/) for the year 
#'of 2015 and has been run through the necessary formatting to be used by the EIAplantAssociation 
#'package.  inputData.list should be in the same format as the example `inputData.list2015` data
#'object.
#'@param bogen.out.list list object generated by the `executeBogenAssoc()` function containing
#'boiler-generator associations
#'@param plantList data.frame indicating which plants to include in the analysis.  Must contain 
#'the column "Plant.Code".  The `data("masterPlantList")` data object contains a list of recommended
#'plants for analysis for the years 2008-2020.
#'@param useStandardCoolType TRUE/FALSE indicating whether to use the `data("combogencoo_cool_type2015")`
#'data object as a starting point to assigning cooling types to boiler-generator-cooling (bogencoo)
#'associations.  If FALSE, user must provide a `path_combogencoo_cool_type` to a file in the same 
#'format as `data("combogencoo_cool_type2015")`.  Option to output user edited combogencoo_cool_type file
#'provided by the `manualBogenReplace()` function for future use in `bocoo.associate()`
#'@param path_combogencoo_cool_type character string indicating the path to a saved combogencoo_cool_type
#'file in *.csv format and structured exactly as the `data("combogencoo_cool_type2015")` object.
#'@param useStandardBogencoo.key TRUE/FALSE indicating whether to use the data("bogencoo.key2015") to
#'fill in boiler-generator-cooling associations for plants that do not report cooling associations in
#'`inputData.list$bocoo`.  Only boiler-generator-cooling associations with matching boiler-generator 
#'associations in `bogen.out.list$sheet3_key` will be used. If FALSE the user should expect many more 
#'manual bogencoos to evaluate. 
#'@return list object including "bogencoo.key" a data.frame of boiler-generator-cooling (bogencoo) 
#'associations, "manualBogencoo" a data.frame containing a list of all plants flagged for manual user
#'checks of the boiler-generator-cooling (bogencoo) associations and/or cooling type assignments, the
#'data.frames "combogencoo_cool_type" and "combogencoo_cool_type_nukes" which are simply the 
#'combogencoo_cool_type file split into non-nuclear plants (in combogencoo_cool_type) and nuclear plants 
#'(in combogencoo_cool_type_nukes).  Note that some plants have both nuclear and non-nuclear units and 
#'will appear in both data.frames.
#'@examples
#'#set arguments
#'dest<-tempdir()
#'eia_year<-2015
#'path_InputData_Metafile<-paste0(dest,.Platform$file.sep,"UserControlCrosswalk2015.xlsx")
#'path_EIAInputData<-paste0(dest,.Platform$file.sep,eia_year)
#'outputCSV<-FALSE
#'path_outputCSV<-dest
#'
#'#use crosswalk2015 object
#'useStandardCrosswalk<-TRUE
#'prepCondenserDuty<-TRUE
#'
#'#pull data from web
#'importThermoEIA::eia_webpull(eia_year,dest)
#'
#'
#'#run import using crosswalk2015
#'inputData.list<-importThermoEIA::import_EIAData(path_InputData_Metafile,path_EIAInputData,outputCSV,
#'                               path_outputCSV,prepCondenserDuty = TRUE,eia_year=eia_year,
#'                               useStandardCrosswalk=useStandardCrosswalk)
#'
#'#load MasterPlantList
#'utils::data("masterPlantList")
#'plantList<-masterPlantList[masterPlantList$year==eia_year,]
#'
#'#run boiler-generator associations
#'bogen.out.list<-executeBogenAssoc(inputData_path,pathWrite,inputData.list,plantList,
#'                                  select_RPM=c("CA", "CS", "CT", "ST",NA), eia_year)
#'
#'#run boiler-generator-cooling associations
#'bogencoo.key.list<-bocoo.associate(inputData.list,bogen.out.list,plantList=plantList)
#'@export

bocoo.associate <- function(inputData.list,bogen.out.list,plantList,
                            useStandardCoolType=T,path_combogencoo_cool_type=NA,
                            useStandardBogencoo.key=T){
  

  
  #unpack data lists
  list2env(inputData.list,envir = parent.frame())
  list2env(bogen.out.list,envir = parent.frame())
  
  #EIA boiler-cooling association table is starting point for all 
  #boiler-generator-cooling associations
  data<-bocoo
  # test: Check that data provided by user is correct
  if(!is.data.frame(data) || 
     length(names(data)[which(names(data) %in% c('Plant.Code', 'Boiler.ID','Cooling.ID'))])<3) {
    stop("data must be a data.frame with columns 'Plant.Code', 'Boiler.ID', and 'Cooling.ID' for this function to continue")
  }
  
  #change names for merging
  names(sheet3_key)[names(sheet3_key)=="bogen"]<-"Bogen"
  
  #format boiler.IDs for bocoo table
  #create flag for Boiler.IDs with special characters, spaces, and/or leading zeros
  #all special characters, spaces, and/or leading zeros will be removed as they are 
  #inconsistent between EIA tables
  data<-formatIDcol(data,idCol="Boiler.ID",
                    flagColname = "flagBoiler.ID_bocoo",
                    originalColname="orig_Boiler.ID_bocoo")

  
  #format boiler.IDs for boilerFuelData
  boilerFuelData<-formatIDcol(boilerFuelData,idCol="Boiler.ID",
                    flagColname = "flagBoiler.ID_bocoo",
                    originalColname="orig_Boiler.ID_bocoo")
  
  
  boilerFuelData<-boilerFuelData %>% dplyr::filter(!is.na(Boiler.ID))
  
  #find Plant.Code^NGCC bogens in boilerFuelData
  NGCCplants<-sheet3_key %>% dplyr::filter(regexpr("NGCC",Bogen)>0)
  NGCCplants<-unique(NGCCplants$Plant.Code)
  boilerFuelData<-boilerFuelData %>% dplyr::filter(Plant.Code %in% NGCCplants & !Reported.Prime.Mover %in% c("CT","ST"))
  
  #join with bocoo associate
  boilerFuelData<-boilerFuelData %>% dplyr::select(Plant.Code,Boiler.ID)
  boilerFuelData<-dplyr::inner_join(boilerFuelData,data,by=c("Plant.Code","Boiler.ID"))
  boilerFuelData<-boilerFuelData %>% dplyr::select(Plant.Code,Boiler.ID,Cooling.ID)
  boilerFuelData<-boilerFuelData %>% dplyr::group_by(Plant.Code) %>% dplyr::summarise(countCooling = length(unique(Cooling.ID)),
                                                                         oneBoiler = dplyr::first(Boiler.ID))
  #find plants with single Cooling.IDs
  boilerFuelData<-boilerFuelData %>% dplyr::filter(countCooling==1)
  names(boilerFuelData)[3]<-"Boiler.ID"
  
  #replace empty Boiler.ID in sheet3_key for NGCC plants with 
  #single Cooling.ID
  NGCCbogen<-sheet3_key %>% dplyr::filter(regexpr("NGCC",Bogen)>0)
  sheet3_key<-sheet3_key %>% dplyr::filter(regexpr("NGCC",Bogen)<0)
  NGCCbogen<-dplyr::left_join(NGCCbogen %>% dplyr::select(-Boiler.ID),boilerFuelData %>% dplyr::select(Plant.Code,Boiler.ID),
                       by=c("Plant.Code"="Plant.Code"))
  NGCCbogen<-NGCCbogen %>% dplyr::select(names(sheet3_key))
  sheet3_key<-rbind(sheet3_key,NGCCbogen)
  
  #order data
  sheet3_key<-sheet3_key[order(sheet3_key$Bogen),]
  sortdata<-data[0,]
for (p in unique(data$Plant.Code)){
  subdata<-data %>% dplyr::filter(Plant.Code==p)
  subBogen<-sheet3_key %>% dplyr::filter(Plant.Code==p)
  subdata<-subdata[match(unique(subBogen$Boiler.ID),subdata$Boiler.ID),]
  sortdata<-rbind(sortdata,subdata)
}
  data<-sortdata
  
  #run associate() for boiler-generator-cooling
  d_out<-associate(data,associationType="bogencoo")
 
  #join associations with bocoo
  bocoo.key <- dplyr::left_join(data,d_out,by=c("Plant.Code","Cooling.ID"))
  bocoo.key$combogencoo<-bocoo.key$result
  bocoo.key<-bocoo.key[,-(which(names(bocoo.key)=="result"))]
  
  #join with sheet3_key
  bogencoo.key<-dplyr::left_join(sheet3_key,bocoo.key)
  
  #add combogen string
  bogencoo.key$combogen<-paste0("combogen^",bogencoo.key$Bogen)
  
  
  #fill missing if only 1 bogen
  oneBogenPlants<-dplyr::ungroup(bogencoo.key) %>% dplyr::select(Plant.Code,Bogen,combogencoo) %>% dplyr::group_by(Plant.Code) %>% dplyr::mutate(countBogens = length(unique(Bogen)))
  oneBogenPlants<-oneBogenPlants %>% dplyr::filter(countBogens==1)
  oneBogenPlants<-oneBogenPlants[!duplicated(oneBogenPlants),]
  oneBogenPlants<-oneBogenPlants %>% dplyr::filter(is.na(combogencoo))
  oneBogenPlants$combogencoo<-paste0("combogencoo^",oneBogenPlants$Plant.Code,"^1")


  bogencoo.key<-dplyr::left_join(bogencoo.key,oneBogenPlants %>% dplyr::select(Plant.Code,combogencoo),by="Plant.Code")
  bogencoo.key$combogencoo<-ifelse(is.na(bogencoo.key$combogencoo.x) & !is.na(bogencoo.key$combogencoo.y),bogencoo.key$combogencoo.y,bogencoo.key$combogencoo.x)
  bogencoo.key<-bogencoo.key %>% dplyr::select(names(bogencoo.key)[!names(bogencoo.key) %in% c("combogencoo.x","combogencoo.y")])
  bogencoo.key<-bogencoo.key[!duplicated(bogencoo.key),]
  
  bogencoo.key$manualEdit<-rep(0,nrow(bogencoo.key))
  
  #select only relevant columns
  if (length(names(bogencoo.key)[names(bogencoo.key) %in% c("manualBogenEdit")])!=0){
  bogencoo.key<-bogencoo.key %>% dplyr::select(manualEdit,manualBogenEdit,Plant.Code, Bogen, combogen,combogencoo,
                                        names(bogencoo.key)[!names(bogencoo.key) %in% 
                                                              c("manualEdit",
                                                                "manualBogenEdit",
                                                                "Plant.Code",
                                                                "Bogen",
                                                                "combogen",
                                                                "combogencoo",
                                                                "manualBogenEditFileName",
                                                                "manualBogenEditDateTime")],
                                        manualBogenEditFileName,manualBogenEditDateTime)
  }else{
    bogencoo.key<-bogencoo.key %>% dplyr::select(manualEdit,Plant.Code, Bogen, combogen,combogencoo,
                                          names(bogencoo.key)[!names(bogencoo.key) %in% 
                                                                c("manualEdit",
                                                                  "manualBogenEdit",
                                                                  "Plant.Code",
                                                                  "Bogen",
                                                                  "combogen",
                                                                  "combogencoo",
                                                                  "manualBogenEditFileName",
                                                                  "manualBogenEditDateTime")])
  }
  
  
  #fill missing bogencoos if same bogen
  for (b in unique(bogencoo.key$combogen)){
    uniqueCombogenCoo<-unique(stats::na.omit(bogencoo.key[bogencoo.key$combogen==b,]$combogencoo))
    if(length(uniqueCombogenCoo)==1){
      bogencoo.key[bogencoo.key$combogen==b,]$combogencoo<-rep(uniqueCombogenCoo,nrow(bogencoo.key[bogencoo.key$combogen==b,]))
    }
  }
  bogencoo.key<-bogencoo.key[order(bogencoo.key$Plant.Code),]
  
  if (useStandardBogencoo.key){
  #if all missing EIA data, use 2015 key IF bogens match
  utils::data("bogencoo.key2015")
  combogencoo.key2015<-bogencoo.key2015
  names(combogencoo.key2015)<-c("combogen2015","combogencoo2015")
  combogencoo.key2015$Plant.Code<-sapply(combogencoo.key2015$combogencoo2015, function(x) as.numeric(strsplit(as.character(x),"\\^")[[1]][2]))
  
  missingBogencoo<-bogencoo.key %>% dplyr::filter(is.na(combogencoo))
  okReplace<-numeric(0)
  for (p in unique(missingBogencoo$Plant.Code)){
    subMissing<-missingBogencoo %>% dplyr::filter(Plant.Code==p)
    sub2015<-combogencoo.key2015 %>% dplyr::filter(Plant.Code==p)
    
    if (nrow(subMissing)!=0 & nrow(sub2015)!=0){
    if (all(unique(subMissing$combogen) %in% unique(sub2015$combogen2015)) &
        all(unique(sub2015$combogen) %in% unique(subMissing$combogen2015))){
      okReplace<-c(okReplace,p)
    }
    }
    
  }
  bogencoo.key<-dplyr::left_join(bogencoo.key,combogencoo.key2015,by=c("Plant.Code"="Plant.Code","combogen"="combogen2015"))
  bogencoo.key$okReplace<-ifelse(bogencoo.key$Plant.Code %in% okReplace,1,0)
  bogencoo.key$combogencoo<-ifelse(bogencoo.key$okReplace==1 & is.na(bogencoo.key$combogencoo) & 
                                     !is.na(bogencoo.key$combogencoo2015),
                                   bogencoo.key$combogencoo2015,bogencoo.key$combogencoo)
  bogencoo.key<-bogencoo.key %>% dplyr::select(-combogencoo2015,-okReplace)
  }#end useStandardBogencoo.key
  
  ###read in combogencoo_cool_type_key and compare
  if (useStandardCoolType){
    utils::data("combogencoo_cool_type2015")
    combogencoo_cooly_type<-combogencoo_cool_type2015
  }else{
  combogencoo_cooly_type <- utils::read.csv(path_combogencoo_cool_type, header=T, stringsAsFactors = F)
  }
  
  manualBogencoo<-dplyr::anti_join(bogencoo.key,combogencoo_cooly_type,by=c("combogencoo"="bogencoo"))
  manualBogencoo<-manualBogencoo[!duplicated(manualBogencoo),]
  manualBogencoo<-manualBogencoo %>% dplyr::select(Plant.Code)
  
  manualBogencoo2<-dplyr::anti_join(combogencoo_cooly_type,bogencoo.key,by=c("bogencoo"="combogencoo"))
  manualBogencoo2$Plant.Code<-sapply(manualBogencoo2$bogencoo, function(x) as.numeric(strsplit(as.character(x),"\\^")[[1]][2]))
  manualBogencoo2<-manualBogencoo2 %>% dplyr::filter(Plant.Code %in% sheet3_key$Plant.Code)
  manualBogencoo2<-manualBogencoo2[!duplicated(manualBogencoo2),]
  
 
  #don't flag mismatches from combogencoo_cooly_type to bogencoo.key IF only 1 cooling sys
  if (eia_year<2012){
    cooling$Cooling.Type.3<-rep(NA,nrow(cooling))
    cooling$Cooling.Type.4<-rep(NA,nrow(cooling))
  }
  cooling<-cooling %>% dplyr::select(Plant.Code,Cooling.ID,Cooling.Type.1,Cooling.Type.2,
                              Cooling.Type.3, Cooling.Type.4)
  cooling<-cooling %>% dplyr::group_by(Plant.Code) %>% dplyr::summarise(c1 = length(stats::na.omit(unique(Cooling.Type.1))),
                                                          c2 = length(stats::na.omit(unique(Cooling.Type.2))),
                                                          c3 = length(stats::na.omit(unique(Cooling.Type.3))),
                                                          c4 = length(stats::na.omit(unique(Cooling.Type.4))))
  cooling<-cooling %>% dplyr::filter(c1==1 & c2==0 & c3==0 & c4==0)
  singleMissing<-manualBogencoo2 %>% dplyr::filter(endsWith(bogencoo,"^1"))
  manualBogencoo2<-manualBogencoo2 %>% dplyr::filter(!endsWith(bogencoo,"^1"))
  manualBogencoo2<-manualBogencoo2 %>% dplyr::filter(!Plant.Code %in% cooling$Plant.Code)
  manualBogencoo2<-rbind(manualBogencoo2,singleMissing)
  manualBogencoo2<-manualBogencoo2 %>% dplyr::select(Plant.Code)
  
  manualBogencoo<-rbind(manualBogencoo,manualBogencoo2)
  manualBogencoo<-manualBogencoo[order(manualBogencoo$Plant.Code),]
 
  #add Plant.Code and manualEdit to combogencoo_cooly_type
  combogencoo_cooly_type$Plant.Code<-sapply(combogencoo_cooly_type$bogencoo, function(x) as.numeric(strsplit(as.character(x),"\\^")[[1]][2]))
  combogencoo_cooly_type$manualEdit<-rep(0,nrow(combogencoo_cooly_type))
  combogencoo_cooly_type<-combogencoo_cooly_type %>% dplyr::select(manualEdit,Plant.Code,
                                                            names(combogencoo_cooly_type)[!names(combogencoo_cooly_type) %in% c("manualEdit","Plant.Code")])
  
    #remove nukes from manualBogencoos
  nukes<-gen_fuel_data

  #find nukes 
  nukes<-gen_fuel_data %>% dplyr::filter(!(is.na(Nuclear.Unit.Id)) &
                                       (Nuclear.Unit.Id!="."))
  #fine non-nukes
  nonNukes<-gen_fuel_data %>% dplyr::filter((is.na(Nuclear.Unit.Id)) |
                                                      (Nuclear.Unit.Id=="."))
  
  #find complexNukes : plants with both nuclear and non-nuclear units
  complexNukes<-nonNukes[nonNukes$Plant.Code %in% nukes$Plant.Code,]$Plant.Code
  
  #nukeOnly plants
  nukes<-nukes %>% dplyr::filter(!Plant.Code %in% complexNukes)
  
  #bogencoo.key includes only non-nuclear plants
  manualBogencoo<-manualBogencoo %>% dplyr::filter(!Plant.Code %in% nukes$Plant.Code)
  
  #check for unreasonable percentages in combogencoo_cooly_type
  bigPercent<-combogencoo_cooly_type %>% 
    dplyr::filter_at(dplyr::vars(dplyr::all_of(names(combogencoo_cooly_type)[!names(combogencoo_cooly_type) %in%
                                   c("Plant.Code","manualEdit","bogencoo")])), 
                     dplyr::any_vars(. >1 & !is.na(.)))
 bigPercent<-data.frame(Plant.Code = unique(bigPercent$Plant.Code))
 manualBogencoo<-rbind(manualBogencoo,bigPercent)
 manualBogencoo<-manualBogencoo[!duplicated(manualBogencoo),]
 manualBogencoo<-manualBogencoo[order(manualBogencoo$Plant.Code),]
  
  #save cool types for nukes
  combogencoo_cooly_type_nukes<-combogencoo_cooly_type %>% dplyr::filter(Plant.Code %in% nukes$Plant.Code | Plant.Code %in% complexNukes)
  combogencoo_cooly_type<-combogencoo_cooly_type %>% dplyr::filter(Plant.Code %in% sheet3_key$Plant.Code)
  

  #if complexNuke make sure combogencoos unique
  bogencoo.key<-bogencoo.key %>% dplyr::mutate(combogencoo = ifelse(Plant.Code %in% 
                                                            complexNukes,paste0(combogencoo,".NonNuke"),
                                                            combogencoo))
  
  


  
  bogencoo.key.list<-named.list(bogencoo.key,manualBogencoo,combogencoo_cooly_type,combogencoo_cooly_type_nukes)
  
  # return output data
  return(bogencoo.key.list)
}
